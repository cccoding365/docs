## 网络部分面试题

### 1. 从 URL 输入到页面展现发生了什么?
1. 在浏览器中输入url
2. 应用层DNS解析域名：先本地查找，再查询DNS服务器
3. 应用层客户端发送HTTP请求
4. 传输层TCP传输报文:三次握手
5. 网络层IP协议查询MAC地址
6. 数据到达数据链路层
7. 服务器接收数据
8. 服务器响应请求
9. 服务器返回相应文件
10. 页面渲染。解析HTML以构建DOM树 –> 构建渲染树 –> 布局渲染树 –> 绘制渲染树。

参考： [从输入URL到浏览器显示页面发生了什么](https://www.cnblogs.com/kongxy/p/4615226.html)

### 2.cookie和session的异同
1. cookie数据存放在客户的浏览器上，session数据放在服务器上。
2. cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗，考虑到安全应当使用session。
3. session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用cookie。
4. 单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie
5. 可以考虑将登陆信息等重要信息存放为session，其他信息如果需要保留，可以放在cookie中。

参考： [Session和Cookie的区别与联系](https://www.cnblogs.com/endlessdream/p/4699273.html)

### 3.说一下http和https的区别
+ https协议需要CA证书，费用较高。
+ http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。
+ http协议的端口为80，https的端口为443。
+ http的连接是无状态的，https协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。
+ 提示：https的ssl加密是在 **传输层** 实现的。

### 4.ssl加密使用了哪种算法，如何加密
1. 在客户端与服务器间传输的数据是通过使用对称算法（如 DES 或 RC4）进行加密的。
2. 公用密钥算法（通常为 RSA）是用来获得加密密钥交换和数字签名的，此算法使用服务器的SSL数字证书中的公用密钥。

### 5.TCP三次握手的过程，为什么是三次而不是两次或者四次？
+ 第一次握手：客户端A发送一个syn（同步）包（syn=x）给服务器B，进入SYN_SEND状态，等待服务器确认
+ 第二次握手：服务端B收到客户端A发送的同步包，确认客户端的同步请求（ack=x+1）,同时也发送一个同步包，
也就是一个ACK包+SYN包服务器进入SYN_RECV状态
+ 第三次握手：客户端A收到服务器B的SYN+ACK包，向服务器B发送一个确认包，此包发送完毕，客户端和服务器进入
ESTABLISHED状态，完成三次握手
+ **三次握手的原因是为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误**

参考： [TCP 为什么是三次握手，而不是两次或四次?](https://www.zhihu.com/question/24853633)

### 6.TCP的四次挥手
+ 第一次：主动关闭方发送一个FIN包，用来关闭主动关闭方到被动关闭方的数据传送，也就是告诉另一方我不再发送数据了，但此时仍可以接收数据
+ 第二次：被动关闭方收到FIN包之后，发送一个确认（ACK）包给对方
+ 第三次：被动关闭方发送一个FIN包，告诉对方不带发送数据
+ 第四次：主动关闭方收到FIN包之后，发送一个ACK包给对方，至此完成四次挥手

### 7.HTTP报文的格式，传输中以何种方式传输
+ HTTP报文分为三个部分，起始行、首部和主体，其中起始行和首部以一个回车和换行符分隔，首部和主体以一个空行分隔，其中起始行是对这次HTTP请求或者响应的描述，请求报文的起始行包括使用的HTTP方法、请求的url地址、HTTP版本，响应报文的起始行包括HTTP的版本，HTTP状态码，http状态码的描述，首部也就是常说的HTTP头部，如Date、Cookie、Content-Type等，主体是这次请求或响应的数据，传输中以明文传输。

参考： [HTTP权威指南](https://book.douban.com/subject/10746113/)

### 8.常见的HTTP头部
+ 可以将HTTP首部分为通用首部、请求首部、响应首部、实体首部，通用首部表示一些通用信息，如Date表示报文创建时间，请求首部就是请求报文中独有的，如cookie、和缓存相关的If-Modified-Since，响应首部就是响应报文中独有的，如set-cookie和重定向有关的location，实体首部用来描述实体部分，如Allow用来描述可执行的请求方法，Content-Type描述主体类型，Content-Encoding描述主体的编码方式

### 9.HTTP状态的简要分类，举例常用的状态码？
+ 可以按照HTTP状态码的第一个数字分类，1xx表示信息，2xx表示成功，3xx表示重定向，这里需要注意的是304，表示未修改，4xx表示客户端错误，最常见的是404，5xx表示服务端错误。
1. 200 OK，表示从客户端发来的请求在服务器端被正确处理
2. 301 moved permanently，永久性重定向，表示资源已被分配了新的 URL
3. 302 found，临时性重定向，表示资源临时被分配了新的 URL
4. 304 not modified，表示服务器允许访问资源，但因发生请求未满足条件的情况
5. 401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息
6. 403 forbidden，表示对请求资源的访问被服务器拒绝
7. 404 not found，表示在服务器上没有找到请求的资源
8. 500 internal sever error，表示服务器端在执行请求时发生了错误
9. 503 service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求

### 10. http 1.0 1.1 2.0的区别
+ **1.0和1.1的区别**
1. 缓存处理：HTTP1.1则引入了更多的缓存控制策略
2. 带宽优化：HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206。
3. 错误通知的管理：在HTTP1.1中新增了24个错误状态响应码
4. Host头处理：HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误
5. 长连接：HTTP 1.1支持长连接和请求的流水线处理，在一个TCP连接上可以传送多个HTTP请求和响应。
+ **1.x和2.0的区别**
1. **新的二进制格式：** HTTP1.x的解析是基于文本。2.0的协议解析决定采用二进制格式，实现方便且健壮。
2. **多路复用：** 即连接共享，即每一个request都是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。
3. **header压缩：** HTTP2.0使用encoder来减少需要传输的header大小，HTTP2.0可以维护一个字典，差量更新HTTP头部，大大降低因头部传输产生的流量。
4. **服务端推送：** 服务端推送能把客户端所需要的资源伴随着index.html一起发送到客户端，省去了客户端重复请求的步骤。

参考： [HTTP1.0、HTTP1.1 和 HTTP2.0 的区别](https://mp.weixin.qq.com/s/GICbiyJpINrHZ41u_4zT-A)

### 11.用户登陆过程的简要说明，如何判断用户是否登录？
+ 用户输入用户名和密码，通过post请求将密码和用户名发送给服务器，服务器比对收到的用户名、密码和数据库中的数据进行比对，不一致则做出响应，反馈信息给客户端，如果比对一致则服务端生成一个session，这个session可以存储在内存、文件、数据库中，同时生成一个与之一一对应的sessionID作为cookie发送给客户端，比对成功之后反馈信息，这时一般会进行一次重定向，重定向至登陆之后的默认页面。判断用户登录则是根据这个sessionID，每次请求会先检查有没有这次类似sessionID的cookie发送过来，没有则认为没有登录，有则是否有相应的session，这个session是否过期等，来判断用户是否登录，登录是否过期。

### 12.tcp和udp的区别
+ TCP是面向连接的，UDP是无连接的即发送数据前不需要先建立连接。
+ TCP提供可靠的服务，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达。UDP尽最大努力交付，即不保证可靠交付。
+ UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。
+ TCP连接只能是点到点、一对一的。UDP支持一对一，一对多，多对一和多对多的交互通信。
+ TCP的首部较大为20字节，而UDP只有8字节。

### 13. Get和Post的区别
+ Get 请求能缓存，Post 不能
+ Post 相对 Get 安全一点点，因为 Get 请求都包含在 URL 里，且会被浏览器保存历史纪录。Post 不会，但是在抓包的情况下都是一样的。
+ URL有长度限制，会影响 Get 请求，但是这个长度限制是浏览器规定的，不是 RFC 规定的。
+ Post 可以通过 request body来传输比 Get 更多的数据，Get 没有这个技术。
+ Post 支持更多的编码类型且不对数据类型限制。
+ Get 多用于无副作用，幂等的场景，例如搜索关键字。Post 多用于副作用，不幂等的场景，例如注册。
+ 备注：副作用指对服务器上的资源做改变，搜索是无副作用的，注册是副作用的。幂等指发送 M 和 N 次请求（两者不相同且都大于 1），服务器上资源的状态一致，比如注册 10 个和 11 个帐号是不幂等的，对文章进行更改 10 次和 11 次是幂等的。因为前者是多了一个账号（资源），后者只是更新同一个资源。

### 14. post请求常见的content-type
1. **application/x-www-form-urlencoded**: 最常见的 POST 提交数据的方式了。浏览器的原生 form 表单，如果不设置 enctype 属性.
2. **multipart/form-data**: 使用表单上传文件时，必须让 form 的 enctyped 等于这个值。一般用来上传文件。
3. **application/json**：告诉服务端消息主体是序列化后的 JSON 字符串。上传复杂的结构化数据。
4. **text/xml**：使用 HTTP 作为传输协议，XML 作为编码方式的远程调用规范。

### 15.什么是正向代理？什么是反向代理？
+ **正向代理** 就是客户端向代理服务器发送请求，并且指定目标服务器，之后代理向目标服务器转交并且将获得的内容返回给客户端。服务器并不知道是谁发的请求，比如翻墙。
+ **反向代理** 代理的是服务器，代理会判断请求走向何处，并将请求转交给客户端，客户端只会觉得这个代理是一个真正的服务器。Nginx就是性能非常好的反向代理服务器，用来做负载均衡。

### 16.介绍一下HTTPS的连接过程
+ HTTPS 还是通过了 HTTP 来传输信息，但是信息通过 TLS 协议进行了加密。
+ TLS 协议位于传输层之上，应用层之下。首次进行 TLS 协议传输需要两个 RTT ，接下来可以通过 Session Resumption 减少到一个 RTT。
+ 在 TLS 中使用了两种加密技术，分别为：对称加密和非对称加密。
+ 连接过程如下：
1. 客户端发送一个随机值以及需要的协议和加密方式。。
2. 服务端收到客户端的随机值，自己也产生一个随机值，并根据客户端需求的协议和加密方式来使用对应的方式，并且发送自己的证书（如果需要验证客户端证书需要说明）
3. 客户端收到服务端的证书并验证是否有效，验证通过会再生成一个随机值，通过服务端证书的公钥去加密这个随机值并发送给服务端，如果服务端需要验证客户端证书的话会附带证书
4. 服务端收到加密过的随机值并使用私钥解密获得第三个随机值，这时候两端都拥有了三个随机值，可以通过这三个随机值按照之前约定的加密方式生成密钥，接下来的通信就可以通过该密钥来加密解密
+ 在 TLS 握手阶段，两端使用**非对称加密的方式来通信**，但是因为非对称加密损耗的性能比对称加密大，所以在正式传输数据时，两端使用**对称加密的方式通信**。

### 17.介绍一下DNS的查找过程？
递归查询

第一步：在hosts静态文件、DNS解析器缓存中查找某主机的ip地址

第二步：上一步无法找到，去DNS本地服务器（即域服务器）查找，其本质是去区域服务器、服务器缓存中查找

第三步：本地DNS服务器查不到就根据‘根提示文件’向负责顶级域‘.com’的DNS服务器查询

第四步：‘根DNS服务器’根据查询域名中的‘xyz.com’，再向xyz.com的区域服务器查询

第五步：www.xyz.abc.com的DNS服务器直接解析该域名，将查询到的ip再原路返回给请求查询的主机

迭代查询参考：[DNS查询过程](https://www.cnblogs.com/vickey-wu/p/6557439.html)

### 18.HTTP的keep-alive是干什么的？
+ HTTP1.1开始,默认采用持久连接,使用了一种叫做keepalive connections 的机制,它可以在传输数据后仍然保持连接,当客户端再次获取数据时,直接使用刚刚空闲下来的连接,而无需再次握手.低线路负载，提高传输速度.
+ Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。
+ HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。
+ keep-alive的优点：
1. 较少的CPU和内存的使用
2. 允许请求和应答的HTTP管线化
3. 降低拥塞控制
4. 减少了后续请求的延迟
5. 报告错误无需关闭TCP链接。


### 19. websocket 和http区别
1. websocket是持久连接的协议,而http是非持久连接的协议.
2. websocket是双向通信协议,模拟socket协议,可以双向发送消息,而http是单向的.
3. websocket的服务端可以主动向客服端发送信息,而http的服务端只有在客户端发起请求时才能发送数据,无法主动向客户端发送信息.

参考： [http,websocket和socket详解](https://blog.csdn.net/qq_38859786/article/details/80523642)

### 20. 强制缓存和协商缓存
+ **强制缓存**： 浏览器在请求某一资源时，会先获取该资源缓存的header信息，判断是否命中强缓存（cache-control和expires信息），若命中直接从缓存中获取资源信息，包括缓存header信息；本次请求根本就不会与服务器进行通信；
+ **协商缓存**： 如果没有命中强缓存，浏览器会发送请求到服务器，请求会携带第一次请求返回的有关缓存的header字段信息（Last-Modified/If-Modified-Since和Etag/If-None-Match），由服务器根据请求中的相关header信息来比对结果是否协商缓存命中；若命中，则服务器返回新的响应header信息更新缓存中的对应header信息，但是并不返回资源内容，它会告知浏览器可以直接从缓存获取；否则返回最新的资源内容
+ 关于缓存是从磁盘中获取还是从内存中获取，查找了很多资料，得出了一个较为可信的结论：Chrome会根据本地内存的使用率来决定缓存存放在哪，如果内存使用率很高，放在磁盘里面，内存的使用率很高会暂时放在内存里面。
参考： [http协商缓存VS强缓存](https://www.cnblogs.com/wonyun/p/5524617.html)
 [http缓存](https://juejin.im/post/5a6c87c46fb9a01ca560b4d7#heading-26)

### 21. 用户操作对缓存的影响
| 操作 | 说明 | 
| ------| ------------------------------ | 
| 打开新窗口 |  如果指定cache-control的值为private、no-cache、must-revalidate,那么打开新窗口访问时都会重新访问服务器。而如果指定了max-age值,那么在此值内的时间里就不会重新访问服务器,例如：Cache-control: max-age=5 表示当访问此网页后的5秒内不会去再次访问服务器. |
| 在地址栏回车 | 如果值为private或must-revalidate,则只有第一次访问时会访问服务器,以后就不再访问。如果值为no-cache,那么每次都会访问。如果值为max-age,则在过期之前不会重复访问。 |
| 按后退按扭 | 如果值为private、must-revalidate、max-age,则不会重访问,而如果为no-cache,则每次都重复访问. |
| 按刷新按扭 | 无论为何值,都会重复访问.（可能返回状态码：200、304，这个不同浏览器处理是不一样的，FireFox正常，Chrome则会启用缓存(200 from cache)） |
| 按强制刷新按钮 | 当做首次进入重新请求(返回状态码200) |


### 21. 什么是跨域，跨域有哪些方法？
+ 只要协议、域名、端口有任何一个不同，都被当作是不同的域。
+ 跨域有如下几种方法：
1. **JSONP**，只能用get方法
2. **通过修改document.domain来跨子域。** 只能把document.domain设置成自身或更高一级的父域。
3. **使用window.name来进行跨域** ；window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的，并不会因新页面的载入而进行重置。
4. **使用HTML5中新引进的window.postMessage方法来跨域传送数据** 使用它来向其它的window对象发送消息，无论这个window对象是属于同源或不同源，目前IE8+、FireFox、Chrome、Opera等浏览器都已经支持window.postMessage方法。
5. **CORS** CORS背后的基本思想就是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功还是失败。它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。
6. **服务器代理**
7. **flash**

### 22. 什么是CORS？如何实现？
+ 允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。
+ 简单请求：
1. 对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个**Origin**字段。Origin字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。
2. 如果Origin指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含**Access-Control-Allow-Origin**字段（详见下文），就知道出错了，从而抛出一个错误，被XMLHttpRequest的onerror回调函数捕获。
3. CORS请求默认不发送Cookie和HTTP认证信息。如果要把Cookie发到服务器，一方面要服务器同意，指定**Access-Control-Allow-Credentials**。另一方面，开发者必须在AJAX请求中打开**withCredentials**属性。
+ 非简单请求：非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json。非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为"预检"请求（preflight）。
1. 浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。
2. "预检"请求用的请求方法是OPTIONS，表示这个请求是用来询问的。头信息里面，关键字段是Origin，表示请求来自哪个源。
3. 除了Origin字段，"预检"请求的头信息包括两个特殊字段。Access-Control-Request-Method和 Access-Control-Request-Headers。
4. 服务器收到"预检"请求以后，检查了Origin、Access-Control-Request-Method和Access-Control-Request-Headers字段以后，确认允许跨源请求，就可以做出回应。
5. 一旦服务器通过了"预检"请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样，会有一个Origin头信息字段。服务器的回应，也都会有一个Access-Control-Allow-Origin头信息字段。

参考材料： [跨域资源共享 CORS 详解](http://www.ruanyifeng.com/blog/2016/04/cors.html)

### 23.写一个jsonp的实现
+ 利用了 **script** 标签没有跨域限制这一“漏洞”来达到与第三方通讯的目的。简单地说，该协议就是，允许用户传递一个callback参数给服务端，然后服务端返回数据时会将这个callback参数作为函数名包裹json数据，这样客户端就可以随意定制自己的函数自动处理返回的数据了。
```JavaScript
    var flightHandler = data=>{
      console.log(data);
    }
    var url = "http://flightQuery.com/jsonp/flightResult.aspx?code=CA1998&callback=flightHandler";
    var script = document.createElement('script');
    script.setAttribute('src', url);
    document.getElementsByTagName('head')[0].appendChild(script);
```